\begin{table}[]
\centering
\caption{Tools available for the de novo assembly of prokaryotic genomes. For each tool, its publication is indicated, if available, as well as the assembly algorithm implemented if it was developed explicitly to handle metagenomic datasets. The tools are ordered by the date of the last update, with the source code indicated when available. The tools incorporated in LMAS are indicated as such. }
\label{tab:ch5_suptable1}
\resizebox{\linewidth}{!}{%
\begin{tabular}{llllllllll}
Name &
  Year of publication &
  Reference &
  Method &
  Explicit for metagenomics &
  Description &
  Source code &
  Date of last release* &
  Docker container &
  Included in the benchmark \\
MetaSPAdes &
  2017 &
  https://dx.doi.org/10.1101\%2Fgr.213959.116 &
  dBg   (multiple k-mer values) &
  yes &
  \begin{tabular}[c]{@{}l@{}}MetaSPAdes is a specific metagenomic pipeline built on top of SPAdes. \\ It constructs the de Bruijn graph of all reads using SPAdes, transforms it into\\ the assembly graph using various graph simplification procedures, and \\ reconstructs paths in the assembly graph that correspond to long genomic \\ fragments within a metagenome.\end{tabular} &
  https://github.com/ablab/spades/ &
  23/07/2021 &
  cimendes/spades:3.15.3-1 &
  yes \\
SPAdes &
  2012 &
  https://dx.doi.org/10.1089\%2Fcmb.2012.0021 &
  dBg   (multiple k-mer values) &
  no &
  \begin{tabular}[c]{@{}l@{}}A tool aiming to resolve uneven coverage in single cell genome data through \\ multiple k-mer sizes of De Brujin graphs. It starts with the smallest k-mer size and and \\ adds hypotetical k-mers to connect graph.\end{tabular} &
  https://github.com/ablab/spades/ &
  23/07/2021 &
  cimendes/spades:3.15.3-1 &
  yes \\
minia &
  2013 &
  https://doi.org/10.1186/1748-7188-8-22 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}The assembly is performed on a data structure based on unitigs produced by the \\ BCALM software and using graph simplifications that are heavily inspired by \\ the SPAdes assembler.\end{tabular} &
  https://github.com/GATB/minia &
  26/05/2021 &
  cimendes/minia:3.2.6-1 &
  yes \\
Unicycler &
  2017 &
  https://doi.org/10.1371/journal.pcbi.1005595 &
  dBg   (multiple k-mer values) &
  no &
  \begin{tabular}[c]{@{}l@{}}Assembly pipeline for bacterial genomes. It can assemble Illumina-only read \\ sets where it functions as a SPAdes-optimiser.\end{tabular} &
  https://github.com/rrwick/Unicycler &
  03/05/2021 &
  cimendes/unicycler:0.4.9-1 &
  yes \\
Abyss &
  2017 &
  http://doi.org/10.1101/gr.214346.116 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}ABySS is a de novo sequence assembler intended for short paired-end reads \\ and genomes of all sizes. It follows the model of minia, wherein a probabilistic \\ Bloom filter representation is used to encode the de Bruijn graph, reducing \\ memory requirements for de novo assembly\end{tabular} &
  https://github.com/bcgsc/abyss &
  22/04/2021 &
  cimendes/abyss:2.3.1-1 &
  yes \\
SKESA &
  2018 &
  https://doi.org/10.1186/s13059-018-1540-z &
  dBg   (multiple k-mer values) &
  no &
  \begin{tabular}[c]{@{}l@{}}Skesa was designed for assembling reads of microbial genomes sequenced \\ using Illumina. The heuristics used are designed to reduce the effect of low-level \\ contamination and strand specific errors in Illumina sequencing on the quality of \\ the assembly.\end{tabular} &
  https://github.com/ncbi/SKESA/releases &
  02/04/2021 &
  cimendes/skesa:2.5.0-1 &
  yes \\
MetaHipMer 2 &
  2018 &
  https://doi.org/10.1109/SC.2018.00013 &
  dBg   (multiple k-mer values) &
  yes &
  \begin{tabular}[c]{@{}l@{}}MetaHipMer pipeline, a high-quality and high-performance metagenome assembler \\ that employs an iterative de Bruijn graph approach. MetaHipMer leverages a specialized\\ scaffolding algorithm that produces long scaffolds and accommodates the idiosyncrasies \\ of metagenomes.\end{tabular} &
  https://bitbucket.org/berkeleylab/mhm2 &
  13/10/2020 &
  cimendes/mhm2:v2.0.0-65-gaad446d-generic &
  yes \\
GATBMiniaPipeline &
  unpublished &
  unpublished &
  dBg   (multiple k-mer values) &
  yes &
  \begin{tabular}[c]{@{}l@{}}The pipeline consists of Bloocoo for error correction, minia for contigs assembly, which \\ is based on the BCALM2 assembler, and the BESST for scaffolding. It was developed \\ to extend Minia assembler to use multiple k-mer values.\end{tabular} &
  https://github.com/GATB/gatb-minia-pipeline &
  31/07/2020 &
  cimendes/gatb-minia-pipeline:31.07.2020-1 &
  yes \\
BCALM2 &
  2016 &
  https://doi.org/10.1093/bioinformatics/btw279 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}Fast and low memory algorithm for graph compaction, consisting of three stages: \\ careful distribution of input k-mers into buckets, parallel compaction of the \\ buckets, and a parallel reunification step to glue together the compacted \\ strings into unitigs.\end{tabular} &
  https://github.com/GATB/bcalm &
  22/05/2020 &
  cimendes/bcalm:2.2.3-1 &
  yes \\
MEGAHIT &
  2015 &
  https://doi.org/10.1093/bioinformatics/btv033 &
  dBg   (multiple k-mer values) &
  yes &
  \begin{tabular}[c]{@{}l@{}}MEGAHIT   is a de novo assembler for assembling large and complex metagenomics\\ data in a time- and cost-efficient manner. It makes use of succinct de Bruijn graph, \\ with a a multiple k-mer size strategy. In each iteration, MEGAHIT cleans potentially \\ erroneous edges by removing tips, merging bubbles and removing low local coverage \\ edges, specially useful for metagenomics which suffers from non-uniform \\ sequencing depths.\end{tabular} &
  https://github.com/voutcn/megahit &
  15/10/2019 &
  cimendes/megahit-assembler:1.2.9-1 &
  yes \\
VelvetOptimizer &
  unpublished &
  unpublished &
  dBg   (multiple k-mer values) &
  no &
  \begin{tabular}[c]{@{}l@{}}The VelvetOptimiser is designed to  as a wrapper script for the Velvet assembler and to \\ assist with optimising the assembly. It searches a supplied hash value range for the \\ optimum, estimates the expected coverage and then searches for the optimum coverage \\ cutoff. It uses Velvet's internal mechanism for estimating insert lengths for paired end \\ libraries. It can optimise the assemblies by either the default optimisation condition or \\ by a user supplied one. It outputs the results to a subdirectory and records all its \\ operations in a logfile.\end{tabular} &
  https://github.com/tseemann/VelvetOptimiser &
  03/08/2017 &
  cimendes/velvetoptimiser:2.2.6-1 &
  yes \\
PANDAseq &
  2012 &
  https://doi.org/10.1186/1471-2105-13-31 &
  OLC &
  no &
  \begin{tabular}[c]{@{}l@{}}PANDASEQ is a program to align Illumina reads, optionally with PCR primers \\ embedded in   the sequence, and reconstruct an overlapping sequence\end{tabular} &
  https://github.com/neufeld/pandaseq &
  03/03/2017 &
  cimendes/pandaseq:2.11-1 &
  no* \\
IDBA-UD &
  2012 &
  https://doi.org/10.1093/bioinformatics/bts174 &
  dBg   (multiple k-mer values) &
  yes &
  \begin{tabular}[c]{@{}l@{}}It's an assembler for assembling reads from single-cell sequencing or metagenomic\\ sequencing technologies with uneven sequencing depths. It employs multiple \\ depth relative thresholds to remove erroneous k-mers in both low-depth and \\ high-depth regions. The technique of local assembly with paired-end information \\ is used to solve the branch problem of low-depth short repeat regions. To speed \\ up the process, an error correction step is conducted to correct reads of \\ high-depth regions that can be aligned to high confidence contigs.\end{tabular} &
  https://github.com/loneknightpy/idba &
  11/07/2016 &
  cimendes/idba:31.12.2016-3 &
  yes \\
Velour &
  2011 &
  http://hdl.handle.net/2142/24291 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}Velour avoids the large memory requirement exhibited by other assemblers by\\ intelligently but efficiently caching portions of the assembly process on disk.  \\ Despite this memory optimization, the solution quality does not suffer and \\ remains comparable to other popular assemblers\end{tabular} &
  https://github.com/jjcook/velour &
  13/05/2016 &
  NA &
  no \\
BBAP &
  2017 &
  https://dx.doi.org/10.1186\%2Fs12859-017-1630-z &
  OLC &
  yes &
  \begin{tabular}[c]{@{}l@{}}Assembly pipeline for the assembly of highly polymorphic metagenomic \\ NGS data sets through a unique BLAST-based greedy algorithm.\end{tabular} &
  http://homepage.ntu.edu.tw/$\sim$youylin/BBAP.html &
  01/12/2015 &
  NA &
  no \\
Metassembler &
  2015 &
  https://doi.org/10.1186/s13059-015-0764-4 &
  OLC &
  yes &
  \begin{tabular}[c]{@{}l@{}}Metassembler combines multiple whole genome de novo assemblies \\ into a combined consensus assembly using the best segments \\ of the individual assemblies.\end{tabular} &
  https://sourceforge.net/projects/metassembler/ &
  23/06/2015 &
  NA &
  no \\
SoapDeNovo2 &
  2012 &
  https://doi.org/10.1186/2047-217X-1-18 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}SOAPdenovo2 is made up of six modules that handle read error correction, \\ de Bruijn graph construction, contig assembly, paired-end reads mapping, \\ scaffold construction, and gap closure.\end{tabular} &
  https://sourceforge.net/projects/soapdenovo2/ &
  17/03/2015 &
  NA &
  no \\
MetaVelvet-SL &
  2015 &
  https://dx.doi.org/10.1093\%2Fdnares\%2Fdsu041 &
  dBg   (single k-mer value) &
  yes &
  \begin{tabular}[c]{@{}l@{}}This De Brujin graph assembler is similar to MetaVelvet, assemblying \\ data by populating a structure estimated from the coverage of nodes \\ (poisson distributions). The De Brujin graph is partitioned into hypothetical \\ subgraphs (possible different species) using these distributions as a guide. \\ Differently from MetaVelvet, MetaVelvet-SL identifies chimeric contigs though\\ a support-vector machine (SVM) trained on paired-end, converage, and \\ contig lenghts for each dinucleotide and passed on to the De Brujin graph for \\ decomposition.\end{tabular} &
  http://metavelvet.dna.bio.keio.ac.jp/MSL.html &
  01/01/2015 &
  NA &
  no \\
Velvet &
  2008 &
  https://dx.doi.org/10.1101\%2Fgr.074492.107 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}Velvet manipulates these de Bruijn graphs efficiently to both eliminate errors\\ and resolve repeats. These two tasks are done separately: first, the error \\ correction algorithm merges sequences that belong together, then the repeat\\ solver separates paths sharing local overlaps.\end{tabular} &
  https://www.ebi.ac.uk/$\sim$zerbino/velvet/ &
  15/08/2014 &
  NA &
  no \\
Ray &
  2010 &
  https://dx.doi.org/10.1089\%2Fcmb.2009.0238 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}A de Bruijn graph de novo assembler that defines specific subsequences, called \\ seeds, and for each of them, the algorithm extends it into a contig. Defined \\ heuristics control the extension process in such a way that the process is stopped \\ if, at some point, the family of reads does not clearly indicate the direction of the \\ extension.\end{tabular} &
  https://sourceforge.net/projects/denovoassembler/files/ &
  12/02/2014 &
  NA &
  no \\
Ray Meta &
  2012 &
  https://doi.org/10.7717/peerj.196 &
  dBg   (single k-mer value) &
  yes &
  \begin{tabular}[c]{@{}l@{}}An extension of the Ray assembler, it applies no graph partitioning nor use a \\ single peak for k-mer coverage, mean, and peak coverage are specific for each \\ seed path. It employs heuristics-based graph transversal and graph is coloured \\ according to an expected taxonomic profile.\end{tabular} &
  https://sourceforge.net/projects/denovoassembler/files/ &
  12/02/2014 &
  NA &
  no \\
PRICE &
  2013 &
  https://dx.doi.org/10.1534\%2Fg3.113.005967 &
  Hybrid   (single k-mer value) &
  yes &
  \begin{tabular}[c]{@{}l@{}}Targeted assembly strategy involved iteratively repeated execution of three steps: \\ (1) for each seed contig, identification of a subset of data that could be assembled \\ to expand the seed contig; (2) performance of an assembly on each seeded dataset; \\ and (3) elimination of redundancy from the products of individual assembly jobs \\ through performance of a meta-assembly on those products\end{tabular} &
  https://sourceforge.net/projects/pricedenovo/ &
  08/05/2013 &
  NA &
  no \\
xGenovo &
  2013 &
  https://peerj.com/articles/196/ &
  OLC &
  yes &
  \begin{tabular}[c]{@{}l@{}}Extended Genovo by adding a bonus parameter in the Chinese Restaurant Process \\ used to get prior accounts for the unknown number of genomes in the sample, \\ intending for a pair of reads to be in the same contig as an effort to solve chimera\\ contig case. Use of relative distance for the number of trials in the symmetric \\ geometric distribution instead of using distance between the offset and the \\ center of contig used in Genovo.\end{tabular} &
  http://xgenovo.dna.bio.keio.ac.jp/download &
  01/01/2013 &
  NA &
  no \\
MetaVelvet &
  2012 &
  https://dx.doi.org/10.1093\%2Fnar\%2Fgks678 &
  dBg   (single k-mer value) &
  yes &
  \begin{tabular}[c]{@{}l@{}}A modified and extended version of the single-genome and de Bruijn-graph based \\ assembler, Velvet, for de novo metagenomic assembly. A decomposing de Bruijn \\ graph constructed from mixed short reads into individual sub-graphs. Building\\ scaffolds is based on every decomposed de Bruijn sub-graph as isolated species genome.\end{tabular} &
  http://metavelvet.dna.bio.keio.ac.jp/src/ &
  29/05/2012 &
  NA &
  no \\
Meraculous &
  2011 &
  https://doi.org/10.1371/journal.pone.0023501 &
  dBg   (single k-mer value) &
  no &
  \begin{tabular}[c]{@{}l@{}}Meraculous relies on an efficient and conservative traversal of the subgraph of the\\ k-mer (deBruijn) graph of oligonucleotides with unique high quality extensions \\ in the dataset, avoiding an explicit error correction step as used in other \\ short-read assemblers.\end{tabular} &
  ftp://ftp.jgi-psf.org/pub/JGI data/meraculous/ &
  20/09/2011 &
  NA &
  no \\
Genovo &
  2010 &
  https://doi.org/10.1007/978-3-642-12683-3   22 &
  OLC &
  yes &
  \begin{tabular}[c]{@{}l@{}}Genovo implements a Chinese restaurant process prior that accounts for the unknown\\ number of genomes in the sample. Inference is made by applying a series of \\ hill-climbing steps iteratively until convergence.\end{tabular} &
  https://cs.stanford.edu/genovo &
  Unknown &
  NA &
  no
\end{tabular}%
}
\end{table}