\begin{table}[]
\centering
\caption{Overview of testing approaches. Software testing can be separated into three types: installation, functionality and destructive. Each component is described, followed by an example on a real-life application on Software X, a hypothetical nucleotide sequence annotation tool}
\label{tab:ch8_table1}
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Name} &
  \textbf{Description} &
  \textbf{Example} \\ \midrule
\multicolumn{3}{c}{\textbf{Installation testing: can the software be invoked on different setups?}} \\ \midrule
Installation testing &
  Can the software be installed on different platforms? &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X can be installed \\ using apt-get, pip, conda and from source.\end{tabular} \\
Configuration testing &
  With which dependencies can the software be used? &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X can be used \\ with different versions of blast+.\end{tabular} \\
Implementation testing &
  \begin{tabular}[c]{@{}l@{}}Do different implementations work \\ similarly enough?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X works the same \\ between the standalone and webserver versions.\end{tabular} \\
Compatibility testing &
  \begin{tabular}[c]{@{}l@{}}Are newer versions compatible with \\ previous input/output?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X can be used with \\ older versions of the UniProtKB database.\end{tabular} \\
Static testing &
  Is the source code syntactically correct? &
  \begin{tabular}[c]{@{}l@{}}Check whether all opening braces have \\ corresponding closing braces or whether \\ code is indented correctly in Software X.\end{tabular} \\ \midrule
\multicolumn{3}{c}{\textbf{Standard functionality testing: does the software do what it should in daily use?}} \\ \midrule
Use case testing &
  \begin{tabular}[c]{@{}l@{}}Can the software do what it is supposed to \\ do regularly?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X can annotate different \\ FASTA files: with spaces in the header, \\ without a header, an empty file, with spaces in \\ the sequence, with unknown characters in the \\ sequences, et cetera.\end{tabular} \\
Workflow testing &
  \begin{tabular}[c]{@{}l@{}}Can the software successfully traverse each \\ path in the analysis?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X works in different \\ modes (using fast mode or using one \\ dependency over the other).\end{tabular} \\
Sanity testing &
  Can the software be invoked without errors? &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X works correctly without \\ flags, or when checking dependencies or \\ displaying help info.\end{tabular} \\ \midrule
\multicolumn{3}{c}{\textbf{Destructive testing: what makes the software fail?}} \\ \midrule
Mutation testing &
  \begin{tabular}[c]{@{}l@{}}How do the current tests handle harmful \\ alterations to the software?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether changing a single addition to a \\ subtraction within Software X causes \\ the test suite to fail.\end{tabular} \\
Load testing &
  At what input size does the software fail? &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X can annotate a small \\ plasmid (10 kbp), a medium-size genome \\ (2 Mbp) or an unrealistically large \\ genome for a prokaryote (1 Gbp).\end{tabular} \\
Fault injection &
  \begin{tabular}[c]{@{}l@{}}Does the software fail if faults are introduced \\ and how is this handled?\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Test whether Software X fails if nonsense \\ functions are introduced in the gene calling code.\end{tabular} \\ \bottomrule
\end{tabular}%
}
\end{table}